# 操作系统 课程设计

## 简单文件系统的实现

### 结构

### 函数

## Linux进程管理

### 4.共享内存、有名信号量
- sender.c

```
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <semaphore.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <fcntl.h>

struct shm_msg {
	pid_t pid;
	char msg[100];
};

int main() {
	sem_t *sem;
	int shmid;
	char msg[100];
	struct shm_msg *shmaddr;
	sem = sem_open("mysem",O_CREAT,0644,1);
	shmid = shmget(ftok(".",1),1024,IPC_CREAT);
	shmaddr = shmat(shmid,0,0);
	shmaddr->pid = -1;
	printf("请输入字符串\n");
	scanf("%s",msg);
	sem_wait(sem);
	shmaddr->pid = 1;
	strcpy(shmaddr->msg,msg);
	printf("sender 发送 %s\n",shmaddr->msg);
	sem_post(sem);
	while(1) {
		if(shmaddr->pid == 0){
			sem_wait(sem);
			printf("sender 接收 %s",shmaddr->msg);
			break;
		}
	}
	sem_post(sem);
	sem_close(sem);
	sem_unlink("mysem");
    return 0;  
}  	

```

- receiver.c 

```
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <semaphore.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <fcntl.h>

struct shm_msg {
	pid_t pid;
	char msg[100];
};

int main()  
{
	sem_t *sem;
	int shmid;
	char msg[100];
	struct shm_msg *shmaddr;
	sem = sem_open("mysem",O_CREAT,0644,1);
	shmid = shmget(ftok(".",1),1024,IPC_CREAT);
	shmaddr = shmat(shmid,0,0);
	while(1) {
		if(shmaddr->pid == 1){
			sem_wait(sem);
			printf("receiver 接收 %s\n",shmaddr->msg);
			strcpy(shmaddr->msg,"over");
			printf("receiver 发送 %s \n",shmaddr->msg);
			shmaddr->pid = 0;
			break;
		}
	}
	sem_post(sem);
	sem_close(sem);
      return 0;  
}  

```	
### 3. 消息队列、无名信号量
```
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <semaphore.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

//	gcc OS-3-3.c -o OS-3-3 -pthread
//	./OS-3-3
//	第三个题和第四个题跑多了好像ftok的key_t会混起来 接收不到信息 改一下或者重启一下就行了

sem_t sem;
int sval;

void sender() {
	sem_wait(&sem);
	key_t key;
	int msqid,msnd;
	char msgp[100] = {0};
	key = ftok(".",1);
	msqid = msgget(key,IPC_CREAT);
	while(1) {
		printf("请输入消息\n");
		scanf("%s",msgp);
		if(strcmp(msgp,"exit")==0){
			strcpy(msgp,"end");
			msnd = msgsnd(msqid,msgp,strlen(msgp),MSG_NOERROR);
			printf("--------------------------------\n");
			printf("发送%d个字符(end),应答信息如下\n",strlen(msgp));
			break;
		}else{
			msnd = msgsnd(msqid,msgp,strlen(msgp),MSG_NOERROR);
			printf("发送%d个字符,输入exit应答\n",strlen(msgp));
		}
	}
	//msnd = msgsnd(msqid,msgp,strlen(msgp),MSG_NOERROR);
	//printf("sender key_t: %d IPC:%d \n",key,msqid);
	sem_post(&sem);
	usleep(100);
	sem_wait(&sem);
	msgrcv(msqid,msgp,100,0,0);
	printf("sender 接收 %s\n",msgp);
	sem_post(&sem);
} 
void receiver() {
	usleep(100);
	sem_wait(&sem);
	//printf("receiver start\n");
	key_t key;
	int msqid;
	int count;
	ssize_t mrcv;
	struct msqid_ds *buf;
	char msgp[100]={0};
	key = ftok(".",1);
	msqid = msgget(key,IPC_CREAT);
	count = 0;
	while(msgrcv(msqid,msgp,100,0,IPC_NOWAIT)!= -1) {
		count++;
		printf("第%d条信息 %s\n",count,msgp);
	}
	strcpy(msgp,"over");
	msgsnd(msqid,msgp,strlen(msgp),MSG_NOERROR);
	printf("receiver 发送 over\n");
	sem_post(&sem);
	usleep(100);
	if(msgctl(msqid,IPC_RMID,buf) == 0)
		printf("消息队列删除成功\n");
	printf("-----------------------------\n");
}
int main(void)  
{  
        pthread_t tid1, tid2;    
        sem_init(&sem, 0, 1);
        pthread_create(&tid1,NULL,sender,NULL);
        pthread_create(&tid2,NULL,receiver, NULL);  
        pthread_join(tid1,NULL); 
        pthread_join(tid2,NULL);  
        sem_destroy(&sem);
        return 0;  
}  	

```

### 2. 管道通信、Posix信号量
```
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <semaphore.h>
#include <string.h>
int main()
{
	int filedes[2];
	pid_t child1;
	pid_t child2;
	pid_t child3;
	char b_read[100]={0};
	int num;
	sem_t sem;
	sem_init(&sem,1,1);
	//int pipe(int filedes[2])
	if(pipe(filedes)<0)
		exit(-1);
	else {
		//close(filedes[0]);
		//close(filedes[1]);
	}
	
	//filedes[0]读 filedes[1]写
	pid_t p1 = fork();
	if(p1==0) {
		sem_wait(&sem);
		close(filedes[0]);
                open(filedes[1]);
                write(filedes[1],"text",4);
                printf("child1 写入 写入值为TEXT\n\n");
                close(filedes[1]);
                sem_post(&sem);
                exit(0);
	}
	pid_t p2 = fork();
	if(p2==0) {
		sem_wait(&sem);
                close(filedes[0]);
                open(filedes[1]);
                write(filedes[1],"text",4);
                printf("child2 写入 写入值为TEXT\n\n");
                close(filedes[1]);
                sem_post(&sem);
                exit(0);
	}
	pid_t p3 = fork();
	if(p3==0) {
		sem_wait(&sem);
		close(filedes[0]);
		open(filedes[1]);
		write(filedes[1],"text",4);
                printf("child3 写入 写入值为TEXT\n\n");
		close(filedes[1]);
		sem_post(&sem);
		exit(0);
	}
	int s1,s2,s3,n;
	//open(filedes[0]);
	close(filedes[1]);
	//waitpid(p1,&s1,0);
	//waitpid(p2,&s2,0);
	//waitpid(p3,&s3,0);
	usleep(100);
	printf("请输入读取数\n");
	scanf("%d",&n);
	printf("读取%d\n\n",n);
	num = read(filedes[0],b_read,n);
	printf("返回值%d,读取值%s\n\n",num,b_read);
	close(filedes[0]);
	return 0;
}

```

### 1. 模拟的shell

- cmd1、cm2、cmd3.c

```
#include<stdio.h>
void  main(){
	printf("cmd1运行完毕\n");
}

```
`gcc cmd1.c -o cmd1`

- shell.c

```
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
void  main(){
	int pid;
	int i;
	char *cmd = (char*)malloc(sizeof(20));
	while(1) {
		printf("输入指令\n");
		scanf("%s",cmd);
                if(strcmp(cmd,"exit")==0)       return;
		pid=vfork();
		if (pid) {
			waitpid(pid,NULL,0);
		}else{
			if(strcmp(cmd,"cmd1")==0 || strcmp(cmd,"cmd2")==0 || strcmp(cmd,"cmd3")==0){
				execl(cmd,cmd,NULL);
			}else{
				printf("Command not found\n");
				_exit(0);
			}
		}
	}
}

```

## Linux内核模块编程
> Makefile 和 OS-2-x.c在同一文件夹内即可

### 2

- Makefile

```
obj-m:=OS-2-2.o
OS22-objs:=OS-2-2.o
KDIR:=/home/kannaduki/linux/linux-4.15.15
PWD:= $(shell pwd)
default:
	make -C $(KDIR) M=$(PWD) modules
clean:
	make -C $(KDIR) M=$(PWD) clean

```

- family.c

```
#include<linux/init.h>
#include<linux/module.h>
#include<linux/kernel.h>
#include<linux/pid.h>
// 内核版本为3.X 则为<linux/sched.h>
#include <linux/sched/signal.h>
#include <linux/moduleparam.h>

static pid_t pid=0;
module_param(pid,int,0644);

static int family_init(void)
{
	struct task_struct *p;
	struct list_head *pp;
	struct task_struct *pl;
        if(pid == 0) {
                printk("输入错误\n");
		return 0;
        }
	p = pid_task(find_vpid(pid), PIDTYPE_PID);
	if(!p) {
		printk("\n\n\n------进程不存在----\n\n\n");
		return 0;
	}
	printk("\n\n\n\n\n\n\n\n\n");
	printk("-----进程号------\n");
	printk("%d\n",pid);
	printk("-----父进程------\n");
	if(p->parent==NULL)
	{
		printk("父进程不存在\n");
	}
        else
	{
		printk("pid: %d 程序名:%s 进程状态: %ld\n",p->parent->pid,p->parent->comm,p->parent->state);
	}
	printk("------兄弟进程-------\n");
	list_for_each(pp,&p->parent->children)
	{
		pl=list_entry(pp,struct task_struct,sibling);
		printk("pid: %d 程序名: %s 进程状态: %ld\n",pl->pid,pl->comm,pl->state);
	}
	printk("---------子进程--------\n");
	if(&p->children==NULL) printk("子进程不存在");
	list_for_each(pp,&p->children)
	{
		pl=list_entry(pp,struct task_struct,sibling);
		printk("pid: %d 程序名: %s 进程状态: %ld\n",pl->pid,pl->comm,pl->state);
	}
	printk("-----------------------\n\n\n\n\n\n");
        return 0;
}
static void family_exit(void)
{
        printk(KERN_ALERT "\n--------Exit---------\n");
}

module_init(family_init);
module_exit(family_exit);
MODULE_LICENSE("GPL");

```

### 1

- Makefile
```
obj-m:=OS-2-1.o
OS21-objs:=OS-2-1.o
KDIR:=/home/kannaduki/linux/linux-4.15.15
PWD:= $(shell pwd)
default:
	make -C $(KDIR) M=$(PWD) modules
clean:
	make -C $(KDIR) M=$(PWD) clean

```

- OS-2-1.c
```
#include<linux/init.h>
#include<linux/module.h>
#include<linux/kernel.h>
// 内核版本为3.X 则为<linux/sched.h>
#include<linux/sched/signal.h>
static int hello_init(void)
{
        struct task_struct *p= &init_task;
	printk(KERN_ALERT"\n\n\n----------------------");
	printk(KERN_ALERT"------所有进程程序名 pid 进程状态 父进程------");
        for_each_process(p) {
	if(p->mm == NULL)
		printk(KERN_ALERT"程序名: %s Pid: %d 进程状态: %ld 父进程pid: %d\n",p->comm,p->pid, p->state,p->real_parent->pid);
        }
	printk(KERN_ALERT"----------------------\n\n\n");
        return 0;
}
static void hello_exit(void)
{
        printk(KERN_ALERT "______Exit______ !\n");
}
module_init(hello_init);
module_exit(hello_exit);
MODULE_LICENSE("GPL");

```

## Linux内核编译及添加系统调用

> 先安装ccache可以大幅节省多次内核编译时间

* 进入内核目录
* 分配系统调用号,修改系统调用表   

```
vim ./arch/x86/entry/syscalls/syscall_64.tbl

尾部添加 [549]为最后一个系统调用号递增
549     64      mysetnice               sys_mysetnice
```
* 申明系统调用服务例程原型  

```
vim ./include/linux/syscalls.h

asmlinkage long sys_mysetnice(pid_t pid,int flag,int nicevalue); //,void __user* prio,void __user* nice);
```
* 实现系统调用服务例程  

```
vim ./kernel/sys.c

SYSCALL_DEFINE3(mysetnice, pid_t, pid, int, flag, int, nicevalue)
{
    struct pid * kpid;
    struct task_struct * task;
    int nicebef;
    kpid = find_get_pid(pid);/* 返回pid */
    task = pid_task(kpid, PIDTYPE_PID);/* 返回task_struct */
    nicebef = task_nice(task);/* 返回进程当前nice值 */
    if(flag == 1)
    {
        set_user_nice(task, nicevalue);/* 修改进程nice值 */
        printk("修改前nice值：%d\t修改后nice值：%d\n", nicebef, nicevalue);
        return 0;
    }
    else if(flag == 0)
    {
        printk("该进程的nice值为%d\n", nicebef);
        return 0;
    }
    return EFAULT;
}

```
* 重新编译内核  

```
make oldconfig
make
make modules
make modules_install
make install
grub2-mkconfig -o /boot/grub2/grub.cfg  //centos
update-grub2  //ubuntu
reboot
```
* 编写用户态程序测试新系统调用  

```
#include <linux/unistd.h>
#include <sys/syscall.h>
#include <stdio.h>
#include <stdlib.h>
#define __NR_mysetnice 549

int main(int argc, char *argv[])
{
     pid_t tid;
     int nicevalue = atoi(argv[1]);
     tid = getpid();
     syscall(__NR_mysetnice,tid,0,0);
     syscall(__NR_mysetnice,tid,1,nicevalue);
     syscall(__NR_mysetnice,tid,0,0);

     //syscall(__NR_mysetnice,tid,flag,nicevalue);
     return 0;
}
```  
* 查看输出内容  

```
dmesg
```
