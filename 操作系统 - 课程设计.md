# 操作系统 课程设计

## 简单文件系统的实现 [到第873行止] 

### 结构

```
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#include<string.h>

#define BLOCKSIZE 1024
#define SIZE 1024000
#define END 65535
#define FREE 0
#define MAXOPENFILE 10
#define CUVER 0
#define APPEND 1

#pragma warning(disable:4996)

typedef struct BLOCK0 {
    char infomation[50];  //你想要提示的第一句话
    unsigned short blocksize;   //设成1024，单位B
    unsigned short totalsize;   //设成1000，单位KB
    unsigned short fat_num; // fat表的数量，设成2
    unsigned short root;// 根目录文件的起始盘块号
    unsigned char *startblock;
    unsigned free_block;    //剩余未使用的块数
}block0;

typedef struct FCB {
    char filename[8];   //文件名
    char exname[3]; //扩展名
    unsigned char attribute;    /*属性，0目录；1文件；(2链接(链接)；3：长文件；4：长文件扩展名)*/
    unsigned short time;
    unsigned short data;
    unsigned short first;
    unsigned long length;
    char free;  //0为空，1相反
    char reserved[7];   //预留，同时也为了内存对齐
}fcb;


/* 这个数据结构为长文件准备，以倒序顺序放在长文件FCB的前面
typedef struct EXTEND_NAME{
    unsigned char endflag; 若end是1则为最后一个EXTEND_NAME，否则为0
    char extname1[10];   扩展名的存储位置1
    unsigned char attribute;    属性，长文件的扩展名的属性为4
    char extname2[20];   扩展名的存储位置2
}ext_name;
*/

typedef struct FAT {
    unsigned short id;
}fat;

typedef struct USEROPEN {
    char filename[8];
    char exname[4];
    unsigned char attribute;
    unsigned short time;
    unsigned short data;
    unsigned short first;
    unsigned long length;
    char free;
    int count; //读写指针的位置
    short fcbstate;// 是否修改了文件的FCB的内容，1：修改；0：未修改
    short topenfile;// 户打开表项是否为空，0：空；1：已分配
}useropen;

unsigned char *myvhard; //虚拟磁盘开始位置的指针
useropen openfilelist[MAXOPENFILE];
char currentdir[100];
unsigned char* startp;  //磁盘数据区开始位置的指针
useropen *ptrcurdir;// 指向用户打开文件表中的当前目录所在打开文件表项的位置

```

### 函数

```
void info() {
    block0 *p = (block0*)myvhard;
    printf("%s\n", p->infomation);
    printf("块大小为:%dB,总大小为:%dKB\n", p->blocksize, p->totalsize);
    printf("fat表数量为:%d\n", p->fat_num);
    printf("数据区的开始块数为:%d\n", p->root);
    printf("剩余未分配块数为:%d\n", p->free_block);
}

void help() {
    printf("\t命令名称\t\t\t解释\n");
    printf("\tinfo\t\t\t获取文件系统整体信息\n");
    printf("\thelp\t\t\t获取所有命令的说明\n");
    printf("\tcd\t\t\t输入参数 dirname ,改变当前目录到指定的名为 dirname 的目录\n");
    printf("\topen\t\t\t输入参数 filename ,打开当前目录下名为 filename 的文件\n");
    printf("\tformat\t\t\t对虚拟磁盘进行格式化,布局虚拟磁盘,建立根目录文件（或根目录区）\n");
    printf("\tmkdir\t\t\t输入参数 dirname ,在当前目录下创建名为 dirname 的子目录\n");
    printf("\trmdir\t\t\t输入参数 dirname ,在当前目录下删除名为 dirname 的子目录\n");
    printf("\tls\t\t\t显示当前目录的内容（子目录和文件信息）\n");
    printf("\tcreate\t\t\t输入参数 filename ,创建名为 filename 的新文件\n");
    printf("\tclose\t\t\t输入参数 fd ,关闭前面由 my_open 打开的文件描述符为 fd 的文件\n");
    printf("\twrite\t\t\t输入参数 fd ,将接下来输入的文本保存到前面由 my_open 打开的文件描述符为 fd 的文件\n");
    printf("\tread\t\t\t输入参数 fd ,将前面由 my_open 打开的文件描述符为 fd 的文件中读取 1024 个字节的文本\n");
    printf("\trm\t\t\t输入参数 filename ,删除名为 filename 的文件\n");
    printf("\texit\t\t\t退出文件系统\n");
    printf("\tshow\t\t\t显示所有已打开文件的fd值\n");
}

void fcbcpy(int i, fcb *fileFcb) {
    strcpy(openfilelist[i].filename, fileFcb->filename);
    strcpy(openfilelist[i].exname, fileFcb->exname);
    openfilelist[i].attribute = fileFcb->attribute;
    openfilelist[i].time = fileFcb->time;
    openfilelist[i].data = fileFcb->data;
    openfilelist[i].first = fileFcb->first;
    openfilelist[i].length = fileFcb->length;
    openfilelist[i].fcbstate = 0;
    openfilelist[i].free = 1;
    openfilelist[i].topenfile = 1;
    openfilelist[i].count = 1;
}

void init_fat1() {
    int i;
    fat *p = (fat*)(myvhard + BLOCKSIZE);
    fat *p1, *p2;
    p1 = p2 = p;
    for (i = 0; i<2 * BLOCKSIZE / sizeof(fat); ++i, ++p1)(p1->id) = FREE;
    for (i = 0; i<7; ++i, ++p2)p2->id = END;
    p[5].id = 6;
}

void init_b0() {
    block0 *p_b0 = (block0*)myvhard;
    strcpy(p_b0->infomation, "File System made by 陈王杰 汤胜中 徐时越 包治宽");
    p_b0->blocksize = BLOCKSIZE;
    p_b0->totalsize = SIZE / 1024;
    p_b0->fat_num = 2;
    p_b0->root = 5;
    p_b0->startblock = myvhard + 5 * BLOCKSIZE;
    p_b0->free_block = (SIZE / BLOCKSIZE) - 6;
}

void bak_fat1() {
    memcpy(myvhard + 3 * BLOCKSIZE, myvhard + BLOCKSIZE, 2 * BLOCKSIZE);
}

void get_time(int *data_time) {
    time_t now;
    time(&now);
    struct tm *nowtime;
    nowtime = localtime(&now);
    data_time[1] = nowtime->tm_hour * 2048 + nowtime->tm_min * 32 + nowtime->tm_sec / 2;  /*前面的两个乘是为了移位*/
    data_time[0] = (nowtime->tm_year - 80) * 512 + (nowtime->tm_mon + 1) * 32 + nowtime->tm_mday;
}

/*创建新文件夹时，传入为为新文件夹分配的块号即可快速完成新文件目录下的.和..的创建*/
/*root参数一般传0就好*/
void fast_dir(int dir_num, int root) {
    int i,j;
    //char* block_start = (char*)myvhard + dir_num * BLOCKSIZE;
    fcb* p = (fcb *)(myvhard + dir_num * BLOCKSIZE);
    for (i = 0; i<BLOCKSIZE / sizeof(fcb); ++i, ++p)p->free = 0;
    fcb *cur = (fcb *)(myvhard + dir_num * BLOCKSIZE);
    fcb *father;
    father = (cur + 1);
    int data_time[2];
    get_time(data_time);
    strcpy(cur->filename, ".");
    strcpy(father->filename, "..");
    strcpy(cur->exname, "di");
    strcpy(father->exname, "di");
    cur->attribute = father->attribute = 0;
    cur->time = father->time = data_time[1];
    cur->data = father->data = data_time[0];
    cur->first = dir_num;
    cur->length = 2 * sizeof(fcb);
    if (root) {
        father->first = cur->first;
        father->length = cur->length;
    }
    else {
        j = get_curnum();
        father->first = openfilelist[j].first;
        father->length = openfilelist[j].length;
    }
    cur->free = father->free = 1;
}

void my_format() {
    init_b0();
    init_fat1();
    bak_fat1();
    fast_dir(5, 1);
}

void startsys() {
    myvhard = (unsigned char*)malloc(SIZE);
    memset(myvhard, 0, SIZE);
    FILE * fp;
    if ((fp = fopen("./my_fs", "r")) != NULL) {
        fread(myvhard, SIZE, 1, fp);
        fclose(fp);
    }
    else {
        printf("The file not exits,create the file to use\n");
        my_format();
    }
    fcbcpy(0, (fcb*)(myvhard + 5 * BLOCKSIZE));
    ptrcurdir = &openfilelist[0];

    /*初始化后面的所有opoenfilelist项*/
    int i;
    for (i = 1; i < MAXOPENFILE; i++) {
        strcpy(openfilelist[i].filename, "\0");
        strcpy(openfilelist[i].exname, "\0");
        openfilelist[i].attribute = 0;
        openfilelist[i].time = 0;
        openfilelist[i].data = 0;
        openfilelist[i].first = 0;
        openfilelist[i].length = 0;
        openfilelist[i].fcbstate = 0;
        openfilelist[i].free = 0;
        openfilelist[i].topenfile = 0;
        openfilelist[i].count = 1;
    }

    /*设置一些全局变量*/
    strcpy(currentdir, "/");
    startp = ((block0 *)myvhard)->startblock;
}

int get_curnum() {
    return(ptrcurdir - openfilelist);
}

int dirst_block() {
    int i, freeBlock;
    fat *fat1 = (fat *)(myvhard + BLOCKSIZE);
    fat *fat2 = (fat *)(myvhard + BLOCKSIZE * 3);
    int flag = 0;
    for (i = 0; i < BLOCKSIZE * 2 / sizeof(fat); i++) {
        if (fat1->id == FREE) {
            flag = 1;
            freeBlock = i;
            return i;
        }
        fat1++;
        fat2++;
    }
    if (flag == 0) {
        printf("FAT满了！");
        return -1;
    }
}

int get_block_num(int start_block) {
    int i = 1;
    fat *fat1 = (fat*)(myvhard + BLOCKSIZE);
    fat *fat_t = fat1 + start_block;
    if (fat_t->id == FREE)return 0;
    else {
        while (fat_t->id != END) {
            ++i;
            fat_t = fat1 + fat_t->id;
        }
    }
    return i;
}

void fast_file(fcb*fileFcb, char *filename, int dirstblock) {
    strcpy(fileFcb->filename, filename);
    strcpy(fileFcb->exname, "txt");
    fileFcb->attribute = 1;
    int time[2];
    get_time(time);
    fileFcb->time = time[1];
    fileFcb->data = time[0];
    fileFcb->first = dirstblock;
    fileFcb->free = 1;
    fileFcb->length = 0;
}

void update_dir(char *filename) {
    if (strcmp(filename, ".") && strcmp(filename, "..")) {
        if (!strcmp(currentdir, "/"))strcat(currentdir, filename);
        else {
            strcat(currentdir, "/");
            strcat(currentdir, filename);
        }
    }

}

void update_dir_father() {
    int last = findlast();
    currentdir[last] = '\0';
}

int findlast() {
    int i, j;
    i = j = 0;
    while (currentdir[i] != '\0') {
        if (currentdir[i] == '/')j = i;
        ++i;
    }
    if (j == 0)++j;
    return j;
}

void my_ls() {
    printf("filename\texname\t\ttime\t\tdata\t\tsize\n");
    /*找到当前目录再openfilelist中得位置*/
    int j;
    int i = get_curnum();
    // 读取当前目录文件的内容到内存
    char *buf = (char *)malloc(1024);
    do_read(i, 1024, buf);
    fcb *fileFcb = (fcb *)buf;
    int num = fileFcb->length / sizeof(fcb);
    for (i = 0; i < num; i++, fileFcb++) {   /*只有fileFCB是真的文件(目录)，i才会增加*/
        if (fileFcb->free == 1) {
            char exname[4];
            for (j = 0; j<3; ++j)exname[i] = fileFcb->exname[i];
            exname[3] = '\0';
            printf("%s\t\t%s\t\t%d:%d:%d\t\t%d,%d,%d\t%d\n", fileFcb->filename, exname, fileFcb->time / 2048, (fileFcb->time % 2048) / 32, (fileFcb->time % 32) * 2, fileFcb->data / 512 + 1980, fileFcb->data % 512 / 32,
                   fileFcb->data % 32, fileFcb->length);
        }
        else i--;
    }
    free(buf);
}

void my_mkdir(char *dirname) {
    // 读取当前目录文件的内容到内存
    useropen *usp = &openfilelist[0];
    int i;
    //找打当前目录在fat表中对应的端口
    for (i = 0; i < MAXOPENFILE; i++, usp++) {
        if (ptrcurdir == usp)
            break;
    }
    int curOpenNum = i;
    char *buf = (char *)malloc(1024);
    do_read(i, 1024, buf);
    // 检查当前目录下新建的目录文件是否重名
    /*fcb的最大块数，实际情况要根据长文件的存在而做一定的调整*/
    fcb *fileFcb = (fcb *)buf;
    int num = fileFcb->length / sizeof(fcb);
    for (i = 0; i < num; i++, fileFcb++) {
        if (!strcmp(fileFcb->filename, dirname)) {
            printf("目录重名\n");
            return;
        }
        if (fileFcb->free == 0)
            i--;
    }

    // 分配空闲文件打开表
    for (i = 0; i < MAXOPENFILE; i++) {
        if (openfilelist[i].topenfile == 0) {
            break;
        }
    }
    if (i == MAXOPENFILE)
    {
        printf("文件打开太多\n");
        return;
    }

    int fd = i;
    // 检查FAT是否有空闲盘块
    fat *fat1 = (fat *)(myvhard + BLOCKSIZE);
    fat *fat2 = (fat *)(myvhard + BLOCKSIZE * 3);
    int freeBlock = 0;

    for (i = 0; i < BLOCKSIZE * 2 / sizeof(fat); i++, fat1++, fat2++)
    {
        if (fat1->id == FREE)
        {
            freeBlock = i;
            break;
        }
    }
    if (i == BLOCKSIZE * 2 / sizeof(fat))
    {
        printf("FAT满了！");
        return;
    }
    // 在目录中分配FCB给新的目录
    fileFcb = (fcb *)buf;
    for (i = 0; i < num; i++, fileFcb++) {
        if (!strcmp(fileFcb->filename, "."))
            fileFcb->length += sizeof(fcb);
        if (fileFcb->free == 0)
            break;
    }
    strcpy(fileFcb->filename, dirname);
    strcpy(fileFcb->exname, "di");
    fileFcb->attribute = 0;
    time_t *now = (time_t *)malloc(sizeof(time_t));
    time(now);
    struct tm *nowtime = localtime(now);
    fileFcb->time = nowtime->tm_hour * 2048 + nowtime->tm_min * 32 + nowtime->tm_sec / 2;
    fileFcb->data = (nowtime->tm_year - 80) * 512 + (nowtime->tm_mon + 1) * 32 + nowtime->tm_mday;
    fileFcb->first = freeBlock;
    fileFcb->free = 1;
    //fileFcb->length = BLOCKSIZE;// 设置文件的长度
    fileFcb->length = 2 * sizeof(fcb);
    //fast_dir(freeBlock,0);
    //ptrcurdir->length += sizeof(fcb);
    // 在新目录分配的磁盘块中建立两个特殊的目录项"." ".."
   fcb *p = (fcb *)(myvhard + freeBlock * BLOCKSIZE);
    // 设置的"." ".."
    strcpy(p->filename, ".");
    strcpy(p->exname, "di");
    p->attribute = 0;
    time(now);
    nowtime = localtime(now);
    p->time = nowtime->tm_hour * 2048 + nowtime->tm_min * 32 + nowtime->tm_sec / 2;
    p->data = (nowtime->tm_year - 80) * 512 + (nowtime->tm_mon + 1) * 32 + nowtime->tm_mday;
    p->first = freeBlock;
    p->length = 2 * sizeof(fcb);
    p->free = 1;
    p++;
    strcpy(p->filename, "..");
    strcpy(p->exname, "di");
    p->attribute = 0;
    time(now);
    nowtime = localtime(now);
    p->time = nowtime->tm_hour * 2048 + nowtime->tm_min * 32 + nowtime->tm_sec / 2;
    p->data = (nowtime->tm_year - 80) * 512 + (nowtime->tm_mon + 1) * 32 + nowtime->tm_mday;
    p->first = ptrcurdir->first;
    p->free = 1;
    p++;
    fat1->id = END;
    fat2->id = END;
    //原来的区域是要写回后才会更新的
    ptrcurdir->length += sizeof(fcb);
    //初始化之后的空间
    for (i = 2; i<BLOCKSIZE / sizeof(fcb); i++, p++)
    {
        p->free = 0;
    }
    do_write(curOpenNum, buf, 1024, 0);
    free(buf);
}

void my_rm(char *filename) {
    int flag;
    // 读取当前目录文件的内容到内存
    char *buf = (char *)malloc(1024);
    useropen *usp = &openfilelist[0];
    int i;
    for (i = 0; i < MAXOPENFILE; i++, usp++) {
        if (ptrcurdir == usp) {
            break;
        }
    }
    int fd = i;
    do_read(i, 1024, buf);
    // 检查要删除的目录是否存在
    fcb *fileFcb = (fcb *)buf;
    int length = fileFcb->length;
    flag = 0;
    for (i = 0; i < length / sizeof(fcb); i++, fileFcb++) {
        if (!strcmp(fileFcb->filename, filename)) {
            flag = 1;
            break;
        }
        if (fileFcb->free == 0)
            i--;
    }
    if (flag == 0) {
        printf("%s目录不存在！\n", filename);
        return;
    }
    // 回收磁盘块
    fat *fat1 = (fat *)(myvhard + BLOCKSIZE);
    fat *fat2 = (fat *)(myvhard + BLOCKSIZE * 3);
    int index = fileFcb->first;
    int indexT;
    do {
        indexT = fat1[index].id;
        fat1[index].id = FREE;
        fat2[index].id = FREE;
        index = indexT;
    } while (index != END);
    // 清空目录项
    fileFcb->filename[0] = '\0';
    fileFcb->free = 0;
    fileFcb = (fcb *)buf;
    // 修改目录的长度
    fileFcb->length -= sizeof(fcb);
    do_write(fd, buf, 1024, 0);
    ptrcurdir->length -= sizeof(fcb);
    free(buf);
}

void my_close(int fd) {
    if (fd >= MAXOPENFILE)
    {
        printf("文件打开表溢出\n");
        return;
    }
    strcpy(openfilelist[fd].filename, "\0");
    strcpy(openfilelist[fd].exname, "\0");
    openfilelist[fd].attribute = 0;
    openfilelist[fd].time = 0;
    openfilelist[fd].data = 0;
    openfilelist[fd].first = 0;
    openfilelist[fd].length = 0;
    openfilelist[fd].fcbstate = 0;
    openfilelist[fd].free = 0;
    openfilelist[fd].topenfile = 0;
    openfilelist[fd].count = 1;
}

void my_rmdir(char *dirname) {
    int i = 0;
    // 读取当前目录文件的内容到内存
    char *buf = (char *)malloc(1024);
    useropen *usp = &openfilelist[0];
    for (i = 0; i < MAXOPENFILE; i++, usp++) {
        if (ptrcurdir == usp) {
            break;
        }
    }
    int fd = i;
    //    curOpenNum = i;
    do_read(i, 1024, buf);

    // 检查要删除的目录是否存在
    fcb *fileFcb = (fcb *)buf;
    int length = fileFcb->length;
    for (i = 0; i < length / sizeof(fcb); i++, fileFcb++) {
        if (!strcmp(fileFcb->filename, dirname)) {
            break;
        }
        if (fileFcb->free == 0)
            i--;
    }
    if (i == length / sizeof(fcb)) {
        printf("目录不存在！\n");
        return;
    }
    // 检查要删除的目录文件是否为空
    fcb *temp = (fcb *)(myvhard + BLOCKSIZE * fileFcb->first);
    if (temp->length > 2 * sizeof(fcb)) {
        printf("目录不为空,确定要删除??\n");
        return;
    }
    int flag = 0;
    // 检查该目录是否已经打开
    for (i = 0; i < MAXOPENFILE; i++) {
        if (strcmp(openfilelist[i].filename, dirname) == 0) {
            flag = 1;
            break;
        }
    }
    if (flag == 1) {// 把打开的目录关闭
        my_close(i);
    }

    // 回收磁盘块
    fat *fat1 = (fat *)(myvhard + BLOCKSIZE);
    fat *fat2 = (fat *)(myvhard + BLOCKSIZE * 3);
    int index = fileFcb->first;
    int indexT;
    //length = fileFcb->length;
    do {
        indexT = fat1[index].id;
        fat1[index].id = FREE;
        fat2[index].id = FREE;
        index = indexT;
    } while (index != END);

    // 清空目录项,将其free设置为0即可,然后是将上层目录的长度进行更新,同时对于openlist中也要更新,因为其指向并不相同.
    fileFcb->filename[0] = '\0';
    fileFcb->free = 0;
    fileFcb = (fcb *)buf;
    fileFcb->length -= sizeof(fcb);
    ptrcurdir->length -= sizeof(fcb);
    do_write(fd, buf, 1024, 0);
    free(buf);
}

void my_create(char *filename) {
    int i = get_curnum();
    int curOpenNum = i;
    int block_num = get_block_num(openfilelist[i].first);
    int fcb_num = openfilelist[i].length / sizeof(fcb);
    char *buf = (char *)malloc(block_num * 1024);
    /* 把所有块的数据都读到buf里面去*/
    do_read(i, block_num * 1024, buf);
    fcb *fileFcb = (fcb *)buf;
    for (i = 0; i < fcb_num; i++, ++fileFcb) {
        if (!strcmp(fileFcb->filename, filename)) {
            printf("文件重名！");
            return;
            break;
        }
        if (fileFcb->free == 0)
            i--;
    }
    int freeBlock = dirst_block();
    if (freeBlock == -1)return;

    // 在目录中分配FCB给新的目录
    fileFcb = (fcb *)buf;
    for (i = 0; i < fcb_num; ++i, ++fileFcb) {
        if (!strcmp(fileFcb->filename, ".")) {
            fileFcb->length += sizeof(fcb);
            /* check if it is root directory*/
            if (fileFcb->first == 5)(fileFcb + 1)->length = fileFcb->length;
        }
        if (fileFcb->free == 0)
            break;
    }
    fast_file(fileFcb, filename, freeBlock);
    ptrcurdir->length += sizeof(fcb);
    do_write(curOpenNum, buf, 1024, 0);
    free(buf);
}

void my_cd(char *dirname) {
    // 打开该目录文件
    int fd = my_open(dirname);
    switch (fd) {
        case -1:printf("该目录为已打开的当前目录\n"); break;
        case -2:printf("该文件不存在\n"); break;
        case -3:printf("返回到上层目录\n"); update_dir_father(); break;
        default:update_dir(dirname); break;
    }

}

int my_open(char *filename) {
    int i = get_curnum();
    int block_num = get_block_num(openfilelist[i].first);
    int fcb_num = openfilelist[i].length / sizeof(fcb);
    char *buf = (char *)malloc(block_num * 1024);
    /* 把所有块的数据都读到buf里面去*/
    do_read(i, block_num * 1024, buf);
    fcb *fileFcb = (fcb *)buf;
    int flag = 0;
    int diroff = 0;
    for (i = 0; i < fcb_num; i++, fileFcb++) {
        if (!strcmp(fileFcb->filename, filename)) {
            flag = 1;
            diroff = i;
            break;
        }
    }
    if (flag == 0)return -2;
    // 检查文件是否已打开
    for (i = 0; i < MAXOPENFILE; i++) {
        if (openfilelist[i].free == 1 && openfilelist[i].first == fileFcb->first) {
            if (!strcmp(fileFcb->filename, "..") && (ptrcurdir->first != 5)) {
                // 找到当前文件夹并关闭
                int j = 0;
                for (j = 0; j<MAXOPENFILE; j++)
                    if (openfilelist[j].free == 1 && (&openfilelist[j]) == ptrcurdir)
                        my_close(j);
                // 打开上级目录
                for (j = 0; j<MAXOPENFILE; j++)
                    if (openfilelist[j].free = 1 && openfilelist[j].first == fileFcb->first)
                        ptrcurdir = &openfilelist[j];
                return -3;
            }
            return -1;
        }
    }
    // 检查文件打开表是否有空表项
    int fd;
    flag = 0;
    for (i = 0; i < MAXOPENFILE; i++) {
        if (openfilelist[i].topenfile == 0) {
            fd = i;
            flag = 1;
            break;
        }
    }
    if (flag == 0) {
        printf("文件打开太多！\n");
        return -1;
    }
    // 填写打开文件表表项
    fcbcpy(i, fileFcb);
    ptrcurdir = &openfilelist[i];
    //printf("%d\n",i);
    /*
    // 设置当前目录为根目录
    strcat(currentdir, filename);
    strcat(currentdir, "\\");
    */
    free(buf);
    printf("打开文件的fd是%d\n", fd);
    return fd;
}

void my_write(int fd) {
    int writeStyle = 0;
    char *text = (char *)malloc(BLOCKSIZE);
    if (fd >= MAXOPENFILE || fd<0)
        printf("超出所能到达范围\n");
    else {
        printf("请输入要写入的内容\n");
        scanf("%s", text);
    }
    do_write(fd, text, BLOCKSIZE, writeStyle);
    free(text);
}

void my_read(int fd, int len) {
    int i;
    int j = 0;
    for (i = 0; i < MAXOPENFILE; i++) {
        if (fd == 0) {
            break;
        }
        if (openfilelist[i].topenfile == 1) {
            fd--;
        }
    }
    fd = i;

    char *text = (char *)malloc(BLOCKSIZE);
    if (fd>MAXOPENFILE || fd<0)
        printf("超过操作边界\n");
    else {
        //printf("%d",do_read(fd,len,text));
        printf("%s\n", text);
    }
}

int  do_read(int fd, int len, char *text) {
    int block_index = openfilelist[fd].first;
    /*读写指针*/
    unsigned char *p = block_index * BLOCKSIZE + myvhard;
    int block_num = len / BLOCKSIZE + 1;
    fat *fat1 = (fat *)(myvhard + BLOCKSIZE);
    int i, j, k = 0;
    //可能占据了多个盘块
    for (i = 0; i < block_num; i++) {
        for (j = 0; j < BLOCKSIZE && k < len; j++, k++, p++)text[k] = *p;
        p = myvhard + BLOCKSIZE * (fat1[block_index].id);
        block_index = fat1[block_index].id;
    }
    //text[k] = '\0';
    return k;
}

int do_write(int fd, char *text, int len, int wstyle) {
    int index = openfilelist[fd].first;// 文件所在的盘块号
    fat *fat1 = (fat *)(myvhard + BLOCKSIZE);
    unsigned char *p = index * BLOCKSIZE + myvhard;
    int block_num = len % BLOCKSIZE == 0 ? (len / BLOCKSIZE) : (len / BLOCKSIZE + 1);
    int i, j, k = 0;
    for (i = 0; i < block_num; i++) {
        for (j = 0; j < BLOCKSIZE && k < len; ++j, ++k) {
            *p = text[k];
            p++;
        }
        p = myvhard + BLOCKSIZE * (fat1[index].id);
        index = fat1[index].id;
    }
    //*p = '\0';
    return 1024;
}

void showOpenFile() {
    int i;
    int j = 0;
    for (i = 0; i < MAXOPENFILE; i++) {
        if (openfilelist[i].topenfile == 1) {
            printf("%d %s\n", j, openfilelist[i].filename);
            j++;
        }
    }
}

void my_exitsys() {
    FILE *fp;
    fp = fopen("./my_fs", "w");
    fwrite(myvhard, SIZE, 1, fp);
    free(myvhard);
    fclose(fp);
    exit(0);
}
void switcher(char *cmd) {
    int fd;
    char command[20];
    if (!strcmp(cmd, "help")) {
        help();
    }
    else if (!strcmp(cmd, "info")) {
        info();
    }
    else if (!strcmp(cmd, "mkdir")) {
        scanf("%s", command);
        if(strlen(command)>=7) printf("目录名过长\n");
        else my_mkdir(command);
    }
    else if (!strcmp(cmd, "rmdir")) {
        scanf("%s", command);
        my_rmdir(command);
    }
    else if (!strcmp(cmd, "ls")) {
        my_ls();
    }
    else if (!strcmp(cmd, "cd")) {
        scanf("%s", command);
        my_cd(command);
    }
    else if (!strcmp(cmd, "create")) {
        scanf("%s", command);
        if(strlen(command)>=7) printf("文件名过长\n");
        else  my_create(command);
    }
    else if (!strcmp(cmd, "write")) {
        scanf("%d", &fd);
        my_write(fd);
    }
    else if (!strcmp(cmd, "read")) {
        scanf("%d", &fd);
        my_read(fd, 1024);
    }
    else if (!strcmp(cmd, "ls")) {
        scanf("%s", command);
        my_rm(command);
    }
    else if (!strcmp(cmd, "open")) {
        scanf("%s", command);
        my_open(command);
    }
    else if (!strcmp(cmd, "close")) {
        scanf("%d", &fd);
        my_close(fd);
    }
    else if (!strcmp(cmd, "exit")) {
        my_exitsys();
        return;
    }
    else if (!strcmp(cmd, "show")) {
        showOpenFile();
    }
    else {
        char c;
        while (1) {
            c = getchar();
            if (c == '\n') break;
        }
        printf("无效指令,请重新输入:\n");
    }
}

int main() {
    startsys();
    printf("输入help以获取帮助!\n");
    char cmd[10];
    while (1) {
        printf("%s:", currentdir);
        scanf("%s", cmd);
        switcher(cmd);
    }
    return 0;
}

```

## Linux进程管理

### 4.共享内存、有名信号量
- sender.c

```
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <semaphore.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <fcntl.h>

struct shm_msg {
	pid_t pid;
	char msg[100];
};

int main() {
	sem_t *sem;
	int shmid;
	char msg[100];
	struct shm_msg *shmaddr;
	sem = sem_open("mysem",O_CREAT,0644,1);
	shmid = shmget(ftok(".",1),1024,IPC_CREAT);
	shmaddr = shmat(shmid,0,0);
	shmaddr->pid = -1;
	printf("请输入字符串\n");
	scanf("%s",msg);
	sem_wait(sem);
	shmaddr->pid = 1;
	strcpy(shmaddr->msg,msg);
	printf("sender 发送 %s\n",shmaddr->msg);
	sem_post(sem);
	while(1) {
		if(shmaddr->pid == 0){
			sem_wait(sem);
			printf("sender 接收 %s",shmaddr->msg);
			break;
		}
	}
	sem_post(sem);
	sem_close(sem);
	sem_unlink("mysem");
    return 0;  
}  	

```

- receiver.c 

```
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <semaphore.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <fcntl.h>

struct shm_msg {
	pid_t pid;
	char msg[100];
};

int main()  
{
	sem_t *sem;
	int shmid;
	char msg[100];
	struct shm_msg *shmaddr;
	sem = sem_open("mysem",O_CREAT,0644,1);
	shmid = shmget(ftok(".",1),1024,IPC_CREAT);
	shmaddr = shmat(shmid,0,0);
	while(1) {
		if(shmaddr->pid == 1){
			sem_wait(sem);
			printf("receiver 接收 %s\n",shmaddr->msg);
			strcpy(shmaddr->msg,"over");
			printf("receiver 发送 %s \n",shmaddr->msg);
			shmaddr->pid = 0;
			break;
		}
	}
	sem_post(sem);
	sem_close(sem);
      return 0;  
}  

```	
### 3. 消息队列、无名信号量
```
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <semaphore.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

//	gcc OS-3-3.c -o OS-3-3 -pthread
//	./OS-3-3
//	第三个题和第四个题跑多了好像ftok的key_t会混起来 接收不到信息 改一下或者重启一下就行了

sem_t sem;
int sval;

void sender() {
	sem_wait(&sem);
	key_t key;
	int msqid,msnd;
	char msgp[100] = {0};
	key = ftok(".",1);
	msqid = msgget(key,IPC_CREAT);
	while(1) {
		printf("请输入消息\n");
		scanf("%s",msgp);
		if(strcmp(msgp,"exit")==0){
			strcpy(msgp,"end");
			msnd = msgsnd(msqid,msgp,strlen(msgp),MSG_NOERROR);
			printf("--------------------------------\n");
			printf("发送%d个字符(end),应答信息如下\n",strlen(msgp));
			break;
		}else{
			msnd = msgsnd(msqid,msgp,strlen(msgp),MSG_NOERROR);
			printf("发送%d个字符,输入exit应答\n",strlen(msgp));
		}
	}
	//msnd = msgsnd(msqid,msgp,strlen(msgp),MSG_NOERROR);
	//printf("sender key_t: %d IPC:%d \n",key,msqid);
	sem_post(&sem);
	usleep(100);
	sem_wait(&sem);
	msgrcv(msqid,msgp,100,0,0);
	printf("sender 接收 %s\n",msgp);
	sem_post(&sem);
} 
void receiver() {
	usleep(100);
	sem_wait(&sem);
	//printf("receiver start\n");
	key_t key;
	int msqid;
	int count;
	ssize_t mrcv;
	struct msqid_ds *buf;
	char msgp[100]={0};
	key = ftok(".",1);
	msqid = msgget(key,IPC_CREAT);
	count = 0;
	while(msgrcv(msqid,msgp,100,0,IPC_NOWAIT)!= -1) {
		count++;
		printf("第%d条信息 %s\n",count,msgp);
	}
	strcpy(msgp,"over");
	msgsnd(msqid,msgp,strlen(msgp),MSG_NOERROR);
	printf("receiver 发送 over\n");
	sem_post(&sem);
	usleep(100);
	if(msgctl(msqid,IPC_RMID,buf) == 0)
		printf("消息队列删除成功\n");
	printf("-----------------------------\n");
}
int main(void)  
{  
        pthread_t tid1, tid2;    
        sem_init(&sem, 0, 1);
        pthread_create(&tid1,NULL,sender,NULL);
        pthread_create(&tid2,NULL,receiver, NULL);  
        pthread_join(tid1,NULL); 
        pthread_join(tid2,NULL);  
        sem_destroy(&sem);
        return 0;  
}  	

```

### 2. 管道通信、Posix信号量
```
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <semaphore.h>
#include <string.h>
int main()
{
	int filedes[2];
	pid_t child1;
	pid_t child2;
	pid_t child3;
	char b_read[100]={0};
	int num;
	sem_t sem;
	sem_init(&sem,1,1);
	//int pipe(int filedes[2])
	if(pipe(filedes)<0)
		exit(-1);
	else {
		//close(filedes[0]);
		//close(filedes[1]);
	}
	
	//filedes[0]读 filedes[1]写
	pid_t p1 = fork();
	if(p1==0) {
		sem_wait(&sem);
		close(filedes[0]);
                open(filedes[1]);
                write(filedes[1],"text",4);
                printf("child1 写入 写入值为TEXT\n\n");
                close(filedes[1]);
                sem_post(&sem);
                exit(0);
	}
	pid_t p2 = fork();
	if(p2==0) {
		sem_wait(&sem);
                close(filedes[0]);
                open(filedes[1]);
                write(filedes[1],"text",4);
                printf("child2 写入 写入值为TEXT\n\n");
                close(filedes[1]);
                sem_post(&sem);
                exit(0);
	}
	pid_t p3 = fork();
	if(p3==0) {
		sem_wait(&sem);
		close(filedes[0]);
		open(filedes[1]);
		write(filedes[1],"text",4);
                printf("child3 写入 写入值为TEXT\n\n");
		close(filedes[1]);
		sem_post(&sem);
		exit(0);
	}
	int s1,s2,s3,n;
	//open(filedes[0]);
	close(filedes[1]);
	//waitpid(p1,&s1,0);
	//waitpid(p2,&s2,0);
	//waitpid(p3,&s3,0);
	usleep(100);
	printf("请输入读取数\n");
	scanf("%d",&n);
	printf("读取%d\n\n",n);
	num = read(filedes[0],b_read,n);
	printf("返回值%d,读取值%s\n\n",num,b_read);
	close(filedes[0]);
	return 0;
}

```

### 1. 模拟的shell

- cmd1、cm2、cmd3.c

```
#include<stdio.h>
void  main(){
	printf("cmd1运行完毕\n");
}

```
`gcc cmd1.c -o cmd1`

- shell.c

```
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
void  main(){
	int pid;
	int i;
	char *cmd = (char*)malloc(sizeof(20));
	while(1) {
		printf("输入指令\n");
		scanf("%s",cmd);
                if(strcmp(cmd,"exit")==0)       return;
		pid=vfork();
		if (pid) {
			waitpid(pid,NULL,0);
		}else{
			if(strcmp(cmd,"cmd1")==0 || strcmp(cmd,"cmd2")==0 || strcmp(cmd,"cmd3")==0){
				execl(cmd,cmd,NULL);
			}else{
				printf("Command not found\n");
				_exit(0);
			}
		}
	}
}

```

## Linux内核模块编程
> Makefile 和 OS-2-x.c在同一文件夹内即可

### 2

- Makefile

```
obj-m:=OS-2-2.o
OS22-objs:=OS-2-2.o
KDIR:=/home/kannaduki/linux/linux-4.15.15
PWD:= $(shell pwd)
default:
	make -C $(KDIR) M=$(PWD) modules
clean:
	make -C $(KDIR) M=$(PWD) clean

```

- family.c

```
#include<linux/init.h>
#include<linux/module.h>
#include<linux/kernel.h>
#include<linux/pid.h>
// 内核版本为3.X 则为<linux/sched.h>
#include <linux/sched/signal.h>
#include <linux/moduleparam.h>

static pid_t pid=0;
module_param(pid,int,0644);

static int family_init(void)
{
	struct task_struct *p;
	struct list_head *pp;
	struct task_struct *pl;
        if(pid == 0) {
                printk("输入错误\n");
		return 0;
        }
	p = pid_task(find_vpid(pid), PIDTYPE_PID);
	if(!p) {
		printk("\n\n\n------进程不存在----\n\n\n");
		return 0;
	}
	printk("\n\n\n\n\n\n\n\n\n");
	printk("-----进程号------\n");
	printk("%d\n",pid);
	printk("-----父进程------\n");
	if(p->parent==NULL)
	{
		printk("父进程不存在\n");
	}
        else
	{
		printk("pid: %d 程序名:%s 进程状态: %ld\n",p->parent->pid,p->parent->comm,p->parent->state);
	}
	printk("------兄弟进程-------\n");
	list_for_each(pp,&p->parent->children)
	{
		pl=list_entry(pp,struct task_struct,sibling);
		printk("pid: %d 程序名: %s 进程状态: %ld\n",pl->pid,pl->comm,pl->state);
	}
	printk("---------子进程--------\n");
	if(&p->children==NULL) printk("子进程不存在");
	list_for_each(pp,&p->children)
	{
		pl=list_entry(pp,struct task_struct,sibling);
		printk("pid: %d 程序名: %s 进程状态: %ld\n",pl->pid,pl->comm,pl->state);
	}
	printk("-----------------------\n\n\n\n\n\n");
        return 0;
}
static void family_exit(void)
{
        printk(KERN_ALERT "\n--------Exit---------\n");
}

module_init(family_init);
module_exit(family_exit);
MODULE_LICENSE("GPL");

```

### 1

- Makefile
```
obj-m:=OS-2-1.o
OS21-objs:=OS-2-1.o
KDIR:=/home/kannaduki/linux/linux-4.15.15
PWD:= $(shell pwd)
default:
	make -C $(KDIR) M=$(PWD) modules
clean:
	make -C $(KDIR) M=$(PWD) clean

```

- OS-2-1.c
```
#include<linux/init.h>
#include<linux/module.h>
#include<linux/kernel.h>
// 内核版本为3.X 则为<linux/sched.h>
#include<linux/sched/signal.h>
static int hello_init(void)
{
        struct task_struct *p= &init_task;
	printk(KERN_ALERT"\n\n\n----------------------");
	printk(KERN_ALERT"------所有进程程序名 pid 进程状态 父进程------");
        for_each_process(p) {
	if(p->mm == NULL)
		printk(KERN_ALERT"程序名: %s Pid: %d 进程状态: %ld 父进程pid: %d\n",p->comm,p->pid, p->state,p->real_parent->pid);
        }
	printk(KERN_ALERT"----------------------\n\n\n");
        return 0;
}
static void hello_exit(void)
{
        printk(KERN_ALERT "______Exit______ !\n");
}
module_init(hello_init);
module_exit(hello_exit);
MODULE_LICENSE("GPL");

```

## Linux内核编译及添加系统调用

> 先安装ccache可以大幅节省多次内核编译时间

* 进入内核目录
* 分配系统调用号,修改系统调用表   

```
vim ./arch/x86/entry/syscalls/syscall_64.tbl

尾部添加 [549]为最后一个系统调用号递增
549     64      mysetnice               sys_mysetnice
```
* 申明系统调用服务例程原型  

```
vim ./include/linux/syscalls.h

asmlinkage long sys_mysetnice(pid_t pid,int flag,int nicevalue); //,void __user* prio,void __user* nice);
```
* 实现系统调用服务例程  

```
vim ./kernel/sys.c

SYSCALL_DEFINE3(mysetnice, pid_t, pid, int, flag, int, nicevalue)
{
    struct pid * kpid;
    struct task_struct * task;
    int nicebef;
    kpid = find_get_pid(pid);/* 返回pid */
    task = pid_task(kpid, PIDTYPE_PID);/* 返回task_struct */
    nicebef = task_nice(task);/* 返回进程当前nice值 */
    if(flag == 1)
    {
        set_user_nice(task, nicevalue);/* 修改进程nice值 */
        printk("修改前nice值：%d\t修改后nice值：%d\n", nicebef, nicevalue);
        return 0;
    }
    else if(flag == 0)
    {
        printk("该进程的nice值为%d\n", nicebef);
        return 0;
    }
    return EFAULT;
}

```
* 重新编译内核  

```
make oldconfig
make
make modules
make modules_install
make install
grub2-mkconfig -o /boot/grub2/grub.cfg  //centos
update-grub2  //ubuntu
reboot
```
* 编写用户态程序测试新系统调用  

```
#include <linux/unistd.h>
#include <sys/syscall.h>
#include <stdio.h>
#include <stdlib.h>
#define __NR_mysetnice 549

int main(int argc, char *argv[])
{
     pid_t tid;
     int nicevalue = atoi(argv[1]);
     tid = getpid();
     syscall(__NR_mysetnice,tid,0,0);
     syscall(__NR_mysetnice,tid,1,nicevalue);
     syscall(__NR_mysetnice,tid,0,0);

     //syscall(__NR_mysetnice,tid,flag,nicevalue);
     return 0;
}
```  
* 查看输出内容  

```
dmesg
```
