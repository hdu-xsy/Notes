# 存储器管理

## 存储器
### 多级存储器体系
`多级存储器体系结构`是包含两个或两个以上容量、性能、价格不同的存储器，用硬件、软件或者两者相结合的方法协调起来组成多级存储器体系  
`CPU寄存器`→临时存储区域[`高速缓存`(Cache)L1/L2/L3→`内存`<物理内存、虚拟内存>]→`永久存储区域`[ROM BIOS、移动存储、网络存储、硬盘]  

```
Cache:有效访问时间=命中率*访Cache时间+(1-命中率)*Cache不命中时花费的时间 即 TA=A·TC+(1-A)·(TC+TM)
```

### 存储器管理功能
* 内存的分配与回收
* 内存的共享和保护  
`内存共享`是指进程共享访问某一段内存空间中的程序或者数据，`内存保护`是为了避免进程间的相互干扰，对内存中的进程和数据进行保护。
* 地址映射  
编译器在对程序进行编译的时候，通常从0开始为程序代码编址，所以程序中涉及的地址都是相对地址0确定的，这种地址称为`虚地址`、`相对地址`或`逻辑地址`。相应的，这些地址构成的地址空间成为`虚地址空间`、`程序空间`或者`逻辑地址空间`。当程序加载到内存中时，通常都不会加载到从0开始的内存空间，程序在物理内存中的地址成为`实地址`、`绝对地址`或`物理地址`，构成的地址空间称为`实地址空间`、`内存空间`或`物理空间`。  
从虚地址映射到实际物理地址的地址转换功能称为`地址映射`，完成这个功能的部件称为`地址映射机构`
* 内存扩充  

### 程序的装入和链接
* 静态链接  
程序装入内存执行前就讲目标模块与库模块链接成为一个完整的执行程序
* 装入时动态链接  
目标模块的链接工作是在程序装入执行时边装入边链接的。
* 运行时动态链接  
程序装入内存时仍然是目标模块，等执行到需要的模块或者库的时候才进行相应的链接。
* 绝对装入  
将程序加载装入到某个指定地址开始的一段内存空间，该地址是在编译时就已经确定的
* 静态重定位装入  
程序加载到内存中任一合适的位置，修改模块中各逻辑地址为统一物理地址空间中的实际物理地址
* 动态重定位装入  
装入时各目标模块中依然使用逻辑地址，当真正执行指令时再将指令本身或指令中数据的逻辑地址转换成物理地址

## 连续存储管理方式  
为进程分配一段连续的物理内存空间，也就是将一维线性连续的虚地址空间映射到一维线性连续的实地址空间的方法

### 固定分区
将物理内存空间划分为大小和数量都固定的若干分区，按照进程的请求分配分区，每个分区只能装入一个程序  
使用分区分配表和相应的分配回收算法实现。  
系统中可以容纳的并发进程的最大数量固定，碎片降低了内存利用率，凡事比最大尺寸大的进程都无法创建和执行


### 可变分区
可变分区的分区大小和数量都是可以变化的，分配的时候根据进程需求分配大小合适的空间，回收的时候相邻分区可以合并成为较大的分区。

* 分配算法
  * 首次适应算法  
  遍历空闲分区表的时候，第一次遇到可以满足需求的分区就进行必要的划分和分配。低端内存反复分配和回收可能出现小的难以利用的碎片空间，这种碎片是在分区之间，所以称为`外部碎片`。如果修改为每次从上一次分配的地方继续往后进行查找，直至空闲表结束再返回表的开始再查找，这称为`循环首次适应算法`
  * 最佳适应算法  
  在空闲分区表中根据分区大小查找与分配请求大小最接近的分区，进行划分和分配。
  * 最坏适应算法  
  在空闲分区表中根据分区大小查找和分配请求大小相差最大的分区，进行划分和分配。
  * 伙伴分配算法，哈西算法，可重定位分区，对换
* 回收算法  
当进程结束释放内存空间的时候，操作系统进行内存回收并标记相应分区为空闲状态。
  * `上邻接`指的是待回收分区R在低端地址与另一个空闲分区F1相邻。回收R时，R与F1合并成为新的F1空闲分区，分区起始地址不变，仍为原来F1的起始地址，但是大小变为F1和R大小之和
  *  `下邻接`指的是待回收分区R在高端地址与另一个空闲分区F2相邻。回收R时，R与F2合并成为新的F2空闲分区，分区起始地址变为原来R的起始地址，大小变为F1和R大小之和
  *  `上下邻接`回收R时，R F1 F2合并成为新的F1空闲分区，分区的起始地址不变，仍为F1的起始地址，但是大小变为R、F1、F2大小只和，并且原来F2分区记录要从空闲分区表中删除，空闲分区表表目数量减一
  *  `无邻接`指的是R不与其他空闲分区相邻。回收R时，需要在合适的位置创建新的空闲分区表目，导致空闲分区表目数量加一。

`紧凑`是把各个进程移动到紧接着另一个进程后面的空间，这样原来不连续的空闲分区就成为高端内存连续的空间了。

## 页式存储管理方式
### 页式存储管理基本原理
* 页与页框  
`页式存储管理`是将内存物理空间和程序逻辑空间分成大小相等的块，一般是2^k B大小。在逻辑空间中的块称为`页面`，物理空间中的块称为物理块，或者`页框`和`帧`。
* 逻辑地址结构  
页式系统的逻辑地址结构包括两部分：叶号P和页内位移量d(又称页内地址)。
在进行地址映射的时候，需要根据给定的逻辑地址A计算得到页号PA和页内地址dA，P=INT[A/L] ，d=[A] mod L，L为页面大小
* 页表
在地址映射的时候需要知道页面对应的物理块，系统为每个进程设置了一张页号到物理块号的映射表，称为`页表`。页表的每个表项`PTE`由页号P与其对应的物理块号F组成，以页号为序建立。
* 地址映射和越界保护  
判断页号是否超过页表长度

`物理地址A' = 页面所对应的物理块号F * 页面大小L + 页内地址d`

### 快表
为了提高内存访问速度，通常会在地址映射机构中增加一个具有并行查找能力的高速缓冲存储器`快表`，也称为联想存储器TLB

### 两级和多级页表
两级页表就是为进程的页表设置一张目录表，用以记录存放进程页面的物理块号，也称为外部页表，或者一级页表，进程自身的页表称为二级页表。二级页表分为三个部分，外部页号P1、外部页内地址P2和页内地址d。若页面大小为2^k ，则页内地址d的位数为k，若页面可以存放页表项PTE的数量为2^m ，则外部页内地址P2的位数为m。

## 段式存储管理方式
* 段  
段式存储管理也属于离散存储器管理方式，但是其划分的单位是有逻辑意义的一组相关信息，称为`段`。每个段都有一个字符串标识符和一个唯一的编号，分别称为段名和段号，每个段都是从0开始连续编址，称为段内地址。
* 逻辑地址结构  
段式存储管理的逻辑地址结构分为两个部分，低位0~15位是段内地址d，高位16~31位为段号S。段式逻辑地址空间是二维的非线性地址空间。段内地址d的位数决定了段的最大长度，段号d的位数决定了一个进程的段的最大数量。
* 段表  
分段后的进程以段为单位装入内存，每个段装入一段连续的内存空间，但各段之间不要求连续，所以分段是离散方式的内存分配。为了访问段，需要建立一张段的映射表，记为各个段在内存中的起始地址（即`段基址`）和段长，称为`段表`，每个分段占一个表项，每个段表由段号、段长和段基址三部分构成，并按照段号排序。
* 地址映射和越界保护  
段号不小于段表长度 段内地址超过段长
* 段共享与保护  
为了实现段共享，可在系统中配置一张共享段表，每个共享段在共享段表中占一个表项。

## 段页式存储管理方式
段页式存储管理首先将逻辑信息分为若干段，然后每个段再按系统规定的页面大小划分为若干页面。段页式的逻辑地址结构分为三个部分，段号S，段内页号P的页内地址d。  
对逻辑地址A进行地址映射时，先根据段表始址和段号S检索段表找到相应的页表，然后根据页号P检索页表，获得物理块号F，最后F和页内地址d一起构成物理地址。  

## 虚拟存储系统
### 虚拟存储器基本概念
`虚拟存储器`是指具有请求调入功能和置换功能，能够利用外存储器的空余空间从逻辑上对内存容量进行扩充的一种存储器系统。

* 时间局部性
* 空间局部性
* 将进程调入的一次性或者整体性改为多次性  
改变进程必须全部调入内存才能运行的方式，只将部分页面(段)装入内存就可启动运行，其余部分暂时存放在外存上，后续逐步调入需要使用的其他部分
* 将进程的驻留性改为置换性  
改变进程一旦调入就一直驻留内存直到结束的方式，在需要的时候将暂时不用的部分换出到外存储器，换入运行所需要的部分。

### 请求分页存储管理方式
* 页表  
  * 页号  
  * 物理块号  
  * 状态位P  
  表示页面是否在内存
  * 访问字段A  
  记录页面被访问的情况
  * 修改位M  
  表示页面装入内存后是否被修改过
  * 外存地址  
  存储页面在外存上的地址
* 缺页中断机制  
在请求分页系统中，当所要访问的页面不在内存中时，地址映射机构讲产生`缺页中断` ，请求操作系统将所缺的页面调入内存。  
缺页中断处理需要经过保护中断现场，分析中断原因，转入中断处理程序，恢复中断现场等几个步骤
* 地址映射机构  
在分页系统地址映射机构的基础上，增加了缺页中断产生及处理、页面换出和换入等功能。
* 抖动/颠簸  
当系统内存过于缺乏的时候，就会频繁地进行页面的换入和换出，导致系统中任务的执行受到严重影响，这种反复频繁进行的页面置换称为`抖动`，即`系统颠簸`
* 工作集  
进程创建及运行时需要有一定数量的物理块分配，称为`工作集`，是在某段时间间隔内，进程要访问的页面集合。
* 页面置换策略  
页面置换策略确定页面如何置换，包括三种策略：可变分配全局置换、可变分配局部置换和固定分配局部置换
* 页面置换算法
  * 缺页中断率f'=不成功访问次数f/(成功访问次数s+f)
  * f'=f(r,m,p)
  * 最佳置换算法OPT  
  选择将来永远不再访问的页面或者最长时间不会访问的页面进行淘汰，以降低缺页率
  * 先进先出置换算法FIFO  
  淘汰最先调入内存的页面
  * 最近最久未使用置换算法LRU  
  淘汰最近一段时间内最长没有被访问的页面
  * 最近最少使用置换算法LFU  
  选择淘汰过去一段时间访问次数最少的页面
  * 时钟置换算法CLOCK(最近未用算法NRU)    
  给每个页面关联一个访问位u，用以记录页面过去一段时间中被访问的情况。

## Linux内存管理机制